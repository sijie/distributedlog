/**
 * Licensed to the Apache Software Foundation (ASF) under one
 * or more contributor license agreements.  See the NOTICE file
 * distributed with this work for additional information
 * regarding copyright ownership.  The ASF licenses this file
 * to you under the Apache License, Version 2.0 (the
 * "License"); you may not use this file except in compliance
 * with the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
syntax = "proto3";

package distributedlog.proto.statestore;

option java_multiple_files = true;
option java_package = "org.apache.distributedlog.statestore.proto";

// KeyRecord holds mvcc metadata for a given key
message KeyMeta {

    // create_revision is the revision of the last creation on the key
    int64 create_revision       = 1;
    // mod_revision is the revision of the last modification on the key
    int64 mod_revision          = 2;
    // version is the version of the most recent value
    int64 version               = 3;

}

// ChangeEvent captures the changes happen to a state store
message ChangeEventMeta {

    enum EventType {
        PUT     = 0;
        DELETE  = 1;
    }

    // type is the kind of the event. If type is a PUT, it indicates
    // new data has been stored to the key. If type is a DELETE, it
    // indicates the key was deleted.
    EventType type              = 1;

    // kv holds the KeyValue for the event.
    // A PUT event contains current kv pair.
    // A PUT event with kv.Version=1 indicates the creation of a key.
    // A DELETE/EXPIRE event contains the deleted key with
    // its modification revision set to the revision of deletion.
    KeyMeta kv                  = 2;

}

message NopRequest {}

message PutRequest {
    // key is the key, in bytes, to put into the key-value store.
    bytes key = 1;
    // value is the value, in bytes, to associate with the key in the key-value store.
    bytes value = 2;
    // lease is the lease ID to associate with the key in the key-value store. A lease
    // value of 0 indicates no lease.
    int64 lease = 3;

    // If prev_kv is set, etcd gets the previous key-value pair before changing it.
    // The previous key-value pair will be returned in the put response.
    bool prev_kv = 4;
}

message DeleteRequest {
    // key is the first key to delete in the range.
    bytes key = 1;
    // range_end is the key following the last key to delete for the range [key, range_end).
    // If range_end is not given, the range is defined to contain only the key argument.
    // If range_end is one bit larger than the given key, then the range is all
    // the all keys with the prefix (the given key).
    // If range_end is '\0', the range is all keys greater than or equal to the key argument.
    bytes range_end = 2;

    // If prev_kv is set, gets the previous key-value pairs before deleting it.
    // The previous key-value pairs will be returned in the delte response.
    bool prev_kv = 3;
}

message RangeRequest {
    // key is the first key for the range. If range_end is not given, the request only looks up key.
    bytes key = 1;
    // range_end is the upper bound on the requested range [key, range_end).
    // If range_end is '\0', the range is all keys >= key.
    // If range_end is key plus one (e.g., "aa"+1 == "ab", "a\xff"+1 == "b"),
    // then the range request gets all keys prefixed with key.
    // If both key and range_end are '\0', then the range request returns all keys.
    bytes range_end = 2;
    // limit is a limit on the number of keys returned for the request.
    int64 limit = 3;

    // count_only when set returns only the count of the keys in the range.
    bool count_only = 9;

    // min_mod_revision is the lower bound for returned key mod revisions; all keys with
    // lesser mod revisions will be filtered away.
    int64 min_mod_revision = 10;

    // max_mod_revision is the upper bound for returned key mod revisions; all keys with
    // greater mod revisions will be filtered away.
    int64 max_mod_revision = 11;

    // min_create_revision is the lower bound for returned key create revisions; all keys with
    // lesser create trevisions will be filtered away.
    int64 min_create_revision = 12;

    // max_create_revision is the upper bound for returned key create revisions; all keys with
    // greater create revisions will be filtered away.
    int64 max_create_revision = 13;
}

message RequestOp {
    oneof op {
        // reserved for range request
        RangeRequest range_op = 1;
        PutRequest put_op = 2; 
        DeleteRequest delete_op = 3;
    }
}

message Compare {
    enum CompareResult {
        EQUAL = 0;
        GREATER = 1;
        LESS = 2;
        NOT_EQUAL = 3;
    }
    enum CompareTarget {
        VERSION = 0;
        CREATE = 1;
        MOD = 2;
        VALUE= 3;
    }
    // result is logical comparison operation for this comparison.
    CompareResult result = 1;
    // target is the key-value field to inspect for the comparison.
    CompareTarget target = 2;
    // key is the subject key for the comparison operation.
    bytes key = 3;
    oneof target_union {
        // version is the version of the given key
        int64 version = 4;
        // create_revision is the creation revision of the given key
        int64 create_revision = 5;
        // mod_revision is the last modified revision of the given key.
        int64 mod_revision = 6;
        // value is the value of the given key, in bytes.
        bytes value = 7;
    }
}

message TxnRequest {
    // compare is a list of predicates representing a conjunction of terms.
    // If the comparisons succeed, then the success requests will be processed in order,
    // and the response will contain their respective responses in order.
    // If the comparisons fail, then the failure requests will be processed in order,
    // and the response will contain their respective responses in order.
    repeated Compare compare = 1;
    // success is a list of requests which will be applied when compare evaluates to true.
    repeated RequestOp success = 2;
    // failure is a list of requests which will be applied when compare evaluates to false.
    repeated RequestOp failure = 3;
}

message Command {
    oneof req {
        NopRequest nop_req = 1;
        PutRequest put_req = 2;
        DeleteRequest delete_req = 3;
        TxnRequest txn_req = 4;
    }
}
